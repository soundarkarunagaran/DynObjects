DynObjects
==========

Overview
--------
DynObjects is a library for C# implementing the commonly occurring concept of "Game Objects". Basically DynObjects serve as dynamically built containers for Components – user classes implementing specific functionality.

Various "Game Object" implementations exist for various platforms (usually game engines), each with its own feature set. The DynObjects library has the following features:

- Dynamically building objects from a set of components.
- Dynamically mutating existing objects by adding or removing components.
- Creating objects from templates, for fast creation.
- Serialization (deserialization) to (from) XML.
- Injection of component dependencies and mandatory components.
- O(1) retrieval of individual components from an object
- Optional retrieval of the containing object from inside a component
- Components can receive events when they're added (removed) to (from) a new (existing) object.
- Disposing an object disposes all components in it that implement IDisposable.
- All operations on DynObjects are done via generated extension methods. The methods are generated by a custom build tool from a flexible scheme written by hand in XML.
- The library is well-integrated with Code Contracts, e.g. component getters are declared with the [Pure] attribute.
- Support for behaviors, i.e. dispatching messages to objects (the classic OOP concept):
  - Components may advertise that they implement a given message by implementing a special interface.
  - A call to any message extension method will call its corresponding method inside the correct component.
  - Support for both unicast (single message implementer) and multicast (multiple message implementers) messages. Multicast messages can be thought of as normal C# events that have their delegates automatically connected or disconnected as components are added or removed.
  - Flexible scheme for resolving ambiguities when multiple components implement the same message. Unicast message implementations can outbid each other in order to select the most appropriate implementer. Multicast message implementations can have a priority on which the invocation list will be sorted.
  - Unicast implementers may call the next bidder for a message. Useful for implementing chains of command.
  - Messages can be generic and also have `out` and `ref` parameters, generic parameter types, generic return types and custom attributes (on their extension methods).
  - Messages can be overloaded.
  - Messages can have default implementations. If one is omitted, the fallback default implementation is to throw a "not implemented" exception for unicast messages or do nothing for multicast messages.
  - Message implementations can be declared virtual.
  - Message invocation is very, very fast – since this is a library intended for game programming, special care was taken to make it as fast as possible. The invocation overhead of a unicast message takes about half the time of a Dictionary lookup with integer keys and about 4x the time of a single static method call. Multicast message calls have an overhead comparable to the unicast ones.
  - The library is well-integrated with the Visual Studio debugger – key library code and the generated code is marked with the `[DebuggerNonUserCode]` attribute so that you never see library code as you step in and out of message invocations.
- Components and messages from multiple assemblies can be combined, mixed and matched, e.g. components may implement messages from different assemblies and objects may have components sets with components from multiple assemblies.
- Licensed under the MIT license.
- ~80kb DLL size in Release.
- Support for .NET 4.0 and Silverlight 4.0 (also can be compiled for .NET 3.5 and Silverlight 3, but no support for Windows Phone for now).

Getting started
---------------
Let's get started. The first order of business is to integrate the library with Visual Studio.
Copy the file `VSTemplates\DynComponents.zip` from the library's main folder into `%USERPROFILE%\Documents\Visual Studio 2010\Templates\ItemTemplates\Visual C#`.

Next, open the DynObjects solution as Administrator, switch to Release and build the BuildDyn project. As a last step it will register itself as a COM component and make itself available as a custom build tool in Visual Studio. You will have to restart Visual Studio after that to apply all changes.

Hello world
-----------
Now that the library is integrated you can use it in your project. To do so, add the Dyn (and/or SilverlightDyn) project to your solution and add a reference to the respective library – Dyn for .NET 4, SilverlightDyn for Silverlight 4, into your project.

Add a New Item to your project – right click on your project, select Add and click New Item. In the Visual C# category (usually at the top of the list) find and select "Dyn Definition". Give it some name, e.g. `GameComponents.dyn` and click add. The new file has the correct overall structure of a Dyn definition.

There will also be a lot of sample component and message definitions (commented out) that you can grok and learn what the format looks like and what it can do. To enable IntelliSense in your .dyn file, add the Dyn.xsd schema to Visual Studio's schemas (this will already be done if you have the Dyn project in your solution) and enable it for every .dyn file in your solution.
You can now write your first component. Create a new class, name it e.g. `RpgStats`. Add a using directive for `namespace Dyn` – everything in the library is located in this namespace. Here's the sample class on which we'll build on:

```
public class RpgStats : Component
{
   private int health = 42;
   public int GetHealth()
   {
      return health;
   }
}
```

Here, we subclass `Component`. This is a very good idea for components, but not mandatory. Next we added some method, which we'll turn into a message.
Now, go to GameComponents.dyn and add the new component to it. Add the following row to the `Components` section:
```
<Component>RpgStats</Component>
```
Next, create the new message. In the Messages section add the following snippet:
```
<Message>
int GetHealth();
</Message>
```
Finally, save the file. The action of saving should automatically invoke the custom build tool and if everything is OK, you should see the generated file "GameComponents.dyn.cs" under the ".dyn" file in the Solution Explorer.

Now that we have the formal definition of the `GetHealth` message, we must now specify that our RpgStats component implements this message. To do so, we implement the generated interface `GetHealth`. This interface is nested in the generated message interfaces class. You can check out its name in the MessageDefsNamespace section of the Dyn definition. Right now it should be named `GameComponentsMsgs`, but please rename it to `GameMsgs` for brevity. Add the interface to the class' interface implementation list:
```
public class RpgStats : Component, GameMsgs.GetHealth
```
That's it – now RpgStats officially implements the `GetHealth` message. The interface defines a single method with the same signature as the one in the Dyn definition and as our existing `GetHealth` method, so we don't need to implement anything more.

Now, let's create an object. The first step is to create an object factory. The factory takes a single parameter – a component provider. A component provider is generated for you by the custom build tool. In the `ComponentProvider` section of the Dyn definition you can check or change the name of this class. Right now it's probably called GameComponents, so let's work with that. Create the factory:
```
var factory = new DynFactory(new GameComponents());
```
Now, let's create an object and invoke a message:
```
var obj = factory.CreateObject(new RpgStats());
int health = obj.GetHealth();
```
Try and launch the project in the debugger and step over each line. Try to step into the invocation of `GetHealth()`. Check out the `obj` variable in the watch – you can see the current component set in the `_components` field and check out every individual component in the debugger.

Terminology
-----------
There is some specific terminology used when discussing game objects and OOP design concepts in general, and this library in particular. A list follows:

- Object – an instance of DynObject, a container object that consists of a set of components and some additional operations.
- Component – the basic building block of an object. In the context of the library, this is a normal C# class that is configured to work with the library.
- Message – an operation or method that can be invoked on the object. Depending on how you configure the message it may have various semantics and behaviors.
- (Message) Implementer – a component that provides an implementation for a given message.
- Message implementation – a method in a component that can be called in the event of a message invocation on the object.
- Invocation (dispatch) – the act of calling the message extension method on an object that will call the correct message implementation. In practice, invocation is just calling a member method on an instance of an object.
- Unicast (message) – unicast messages are ones that must have exactly zero or one implementers in a given object.
- Multicast (message) – multicast messages may have any number of implementers. All implementers (subject to configuration) will be called when the message is dispatched on the object. In this sense multicast messages behave much like C# events.
- Canonical component set – the set of components that can validly comprise an object. The canonical component set may be larger than the set of components used to construct an object due to dependency injection, mandatory components and other type analysis rules.

Anatomy of the Dyn definition
-----------------------------
###Conventions
The Dyn definition is designed to be easy to edit by hand. A lot of the elements have Boolean attributes. Those attributes can have the values 0, 1, False, True. All Boolean fields are false by default (when not explicitly specified), unless explicitly stated otherwise.

###Structure
Every element in the Dyn definition is used in some way to generate the code necessary to work with components and messages.
It has the following top-level tags:

- `RootNamespace` – the namespace where all code will be generated. This is also the namespace where all extension methods are defined, so you must put it in a using directive everywhere you want to use the respective extension methods – both component getters and message invokers.
- `ComponentProvider` – this is the name of the class that will serve as a component provider for this definition. You supply an instance of this class in the call to DynFactory's constructor.
- `UsingNamespaces` – this is a list of namespaces that will be used in the generated code. Each namespace is specified in a Namespace sub-element. Usually, you'll add more namespaces here whenever a message works with parameter or return types that are not accessible from the root namespace, e.g. if you need to pass a parameter of type StringBuilder, you'll need to add System.Text to this list of namespaces.
- `Components` – this is a list of all components that will be used as part of this dyn definition.
- `Messages` – this is a list of all messages that will be used as part of this dyn definition.
- `DefaultMessageImplementationClass` – this is the name of the class where you will add default implementations for unicast messages. More on default implementations later.
- `MessageDefsNamespace` – this is the class (used as a pseudo-namespace) that nests all message interfaces and delegates. Use some short name for this class, since you'll be using it around a lot.

###Components element
The Components element contains a list of Component elements. Each Component element specifies a component that can be used with this dyn definition. The value of the element specifies the name of the class that implements the component, e.g. if you add a component named `RpgStats` to the Dyn definition, then this requires that you have a class named `RpgStats` in the dyn definition root namespace.
The following convention is used for classes that are outside the root namespace. Let's say that the root namespace is A:

- If we have a component `C1` in namespace `A`, then we simply write `C1` for the class name.
- If we have a component `C2` in an unrelated namespace`B.C`, then we write the fully qualified name of the class: `B.C.C2`.
- If we have a component `C3` in a namespace nested in `A`, e.g. `A.E.C3`, then we write the fully qualified name of the class (`A.E.C3`), but omit the part of it that is the same as the root namespace, i.e. we write: `E.C3`.

The Component element has the following attributes:

- `Accessor` – the suffix of the component's accessor. Usually the component's accessor is named "Get{Component class name}", e.g. GetRpgStats() for the RpgStats component. If you add the attribute `Accessor="Stats", then the getter will be called GetStats().
- `NoAccessor` – Boolean field, if true then no accessor will be generated.

The Components element can have (besides all Component sub-elements) a single special sub-element named `MulticastBeacon`. Its properties are discussed in the Multicast beacon section of the document.

###Messages element
The `Messages` element contains a list of `Message` sub-elements, one for each message that can be used with this Dyn definition. The value of the Message element must contain the signature of the message. For example if you want a message with the signature `int GetHealth()`, you write `int GetHealth();` as the value of a Message element. The signature largely follows the syntax of C#, e.g. `int Bar(int a, char b, string c)`, `int TestMessage1(out bool result)`, etc. Any attributes can be prepended to the signature, e.g. `[Pure] void Foo();`.
One notable difference is that in order to use generic types, you must substitute the <> brackets for the {} braces in the signature, e.g. the proper message element value for the method signature `Dictionary<int, T> GetValues<T>(IEnumerable<int> indexes)` is: `Dictionary{int, T} GetValues{T}(IEnumerable{int} indexes);`.
The Message element has the following attributes:

- `Multicast` – Boolean field. If true then this is a multicast message, otherwise this is a unicast message.
- `HasDefaultImpl` – Boolean field. If true, then the user must supply a default implementation, otherwise the default implementation will be supplied by the library.
- `GenerateBeacon` – used only for multicast messages, specifies whether to create a multicast beacon for this message. For more information read the Multicast beacon section of this document.
- `Overload` – the name of the overload, if this is an overloaded message. For more information read the Message overloads section of this document.
- `ThruInterface` – Boolean field. This is an advanced field, so you shouldn't need to use it. If true, then the message invocation will be done through an interface call, instead of a delegate call. This field is implicitly true if the message is generic. This must be set to true only in the case where message interface implementations may be explicit. Since setting this field to true has a performance penalty (especially for multicast messages), it is recommended to never use it and always use implicit interface implementations for messages.

Anatomy of the library
----------------------
Classes:

- `ComponentProvider` – this is an abstract base class for user component providers. You don't need to inherit from it manually; all necessary code, including a proper subclass is generated by the custom build tool from your Dyn definition.
- `DynFactory` – this is the factory from which you create all your objects. It is initialized with an instance of each of your component providers.
- `DynObject` – this is the container object that may contain any components and have extension methods invoked on it.
- `Component` – this is a base class that allows components to communicate with their container object.
- `TypeInfo` – this class represents the "type" of a DynObject. It's a combination of information for object reflection and a vtable for message invocation. You don't usually need to use methods in this class. Its most useful feature is allowing you to quickly create new objects with the same component set as existing ones.
- `DynException` – the exception type used throughout the library for incorrect usage of the library.

###Library workflow

The list of activities associated with integrating the library may be given in this ordered list:

1. Create a Dyn definition from the template. Specify class names to your liking, e.g. the message interfaces namespace, the root namespace, the component provider name, etc.
- Create your first component. Preferably (but not necessarily) subclass it from Component. Add it to the Components section of your Dyn definition.
- Write your first component methods. Add the relevant method signatures to the Messages section of your Dyn definition. Note that not all methods must be messages.
- Create your DynFactory singleton.
- Create your first DynObject.

###Object operations
A list of the most common features of the library that you will use follows below.

####Creation
Object creation is done by calling the `DynFactory.CreateObject()` method and supplying to it all component instances that will comprise the object. The `CreateObject()` method will analyze the supplied set, create (or reuse) the appropriate TypeInfo and create the object from it. The final set of components present in the object after dependency injection and type analysis is called the canonical component set of that object. When you create an object you don't have to give an instance of every component in the canonical set – those can be default-constructed if necessary. This allows you to specify only the components that are semantically important for determining the object type and have the rest injected automatically to reduce all the clutter in the `CreateObject()` call. Note that this is impossible if any of the omitted components don't have a default (parameter-less) constructor.

A component may only appear once in the component set of an object. If you try to pass a component of the same type twice, or a class instance that is not registered as a component, then an exception will be thrown.

Object creation will call the OnDynObjectCreated event in Component.

####Disposal
No class in the library needs to be disposed by itself. DynObject implements the IDisposable interface and its implementation of Dispose() just calls Dispose() on all constituent components that implement IDisposable. Thus you only need to call DynObject.Dispose() in the event that any of your components actually need disposal.

Anyway, all objects will be garbage collected without leaking resources when the time comes.

####Mutation
You can transform the type of one object to another on the fly by adding and removing components from (to) the object. This is done with the `DynObject.Mutate()` method. The most common form of this method is to provide a list of components to add and remove, e.g.:

```
obj.Mutate(new SomeComponent(), typeof(AnotherComponent));
```

You can pass two categories of object types to Mutate:
- Objects of type `System.Type`: these are understood to be removal operations. In the above example `AnotherComponent` will be removed from the object.
- Objects of any other type: these are understood to be insertion operations. In the above example `SomeComponent` will be added to the object.

After this operation, the `TypeInfo` of the object will reflect its new object type. Dependency injection and type analysis rules are enforced as usual during mutation. This also means that you cannot remove mandatory or dependent components. `Mutate()` silently swallows some invalid operations, like removal of types that don't exist in the object anyway, or removal of components that are still required by type analysis. It is, however, an error to add a new component that already exists in the object.

When removing components, all automatically injected components are NOT removed along. You must remove them explicitly.

Mutation will call the `OnDynObjectMutated` event in Component for all remaining components in the object. Components removed due to a mutation will have their `Dispose()` method called (if they implement `IDisposable`), but will not receive the `OnDynObjectMutated` event.

###Message invocation, return types
Messages are invoked on objects by using the associated extension method generated from the Dyn definition. Implementations of unicast messages can return any value which will then be returned by the extension method at the call site. Unicast messages can use both `out` and `ref` parameters. Multicast messages can't return anything; their return type must always be void. Multicast messages can gather data from multiple implementers by using `ref` parameters or mutable classes that are passed by reference, e.g. `List<T>` instances.

###Component operations
User components ought to inherit the class Component. This is the class that gives the component access to its container object.

Members of Component:
- `DynThis` – this property stores a reference to the containing object. This property is valid as soon as the OnDynObjectCreated event has been fired. This property will be null if the component is not currently part of a working DynObject.
- `OnDynObjectCreated()` – virtual method called as soon as the DynObject instance is fully assembled and all DynThis members in all components have been initialized. This method represents the earliest point in time where components may perform operations on their container and/or sibling components.
- `OnDynObjectMutated()` – virtual method called whenever the containing has been mutated. It receives two parameters – "IEnumerable<object> componentsAdded" and "IEnumerable<Type> componentsRemoved" which designate what mutations have been performed on this object.
- `DynObjectCreated` – an event fired by default when there is no custom implementation for `OnDynObjectCreated()`.
- `DynObjectMutated` – an event fired by default when there is no custom implementation for `OnDynObjectMutated()`.

`DynThis` is in fact the most interesting member of Component. By inheriting from `Component` you receive the member property `DynThis` that grants you access to the container object. You can use it to invoke messages and retrieve sibling components just like you can with any other instance of `DynObject`.

Advanced concepts
-----------------

###Factory lifetime, multiple component providers
It is common for multiple assemblies to provide their own set of components and messages. You can mix them together into a super-component provider. This is done with the `ComponentProvider.Merge()` method. Suppose you have two component providers named `ServerComponents` and `ClientComponents`. On the client you'd like to use both, so you create a factory in the following way:

```
var factory = new DynFactory(ComponentProvider.Merge(new ServerComponents(), new ClientComponents()));
```

As a rule, objects created from different factory instances shouldn't be used together. As a pattern, the factory should be treated as a singleton and it is best to have a single place where you create a single factory from the merger of all available component providers. This is usually done in the initialization code of the main application – be it an .exe, a Silverlight application or a web application. Libraries should not create their own factories. Instead, there should be a way in which the libraries can get access to the factory singleton. As a rule of thumb a factory should be stored in a static field somewhere and initialized only once during the initialization of the main application.

This isn't actually mandatory, as you can still create multiple factories from unrelated component providers if you're careful not to call messages from a component provider registered with one factory on objects created from another factory.

Note: a given component provider can only be used with a single factory. Also, the factory constructor call with a given component provider (or set thereof) must be called exactly once for the lifetime of the application.

###Dependency injection
Components may have dependencies between them. Whenever you create an object from a set of components, all necessary dependencies will be injected alongside them. For example, suppose that you have a `ModelComponent` and a `ViewComponent`. You'd like to automatically inject the `ViewComponent` when an object is created with the `ModelComponent`. To do so, use the `DynFactory.AddInjectionRule()` method:

```
factory.AddInjectionRule(typeof(ModelComponent), typeof(ViewComponent));
```

The first parameter is the type of the component that has a dependency. The second parameter is the type of the component to inject.

Now if you create an object like so:
```
var obj = factory.CreateObject(new ModelComponent());
```
and inspect `obj` in the debugger, you'll see that it has both an instance of `ModelComponent` and `ViewComponent`.

Another use case is when you want all objects created from the factory to have a specific component, regardless the specified component set. This is done with the `DynFactory.AddMandatoryComponent()` method.

A general type analysis can also be applied to component sets. This is done by implementing the `ITypeAnalysisRule` interface and supplying an instance of it to `DynFactory.AddTypeAnalysisRule()`. Implementers may perform changes to the supplied list of component types until happy.

Note: all calls to `AddInjectionRule`, `AddMandatoryComponent` and `AddTypeAnalysisRule` must happen before the first `TypeInfo` object is created, i.e. before beginning useful work with the factory. As a rule of thumb, add all type analysis rules right after creating the factory.

###Default message implementations
It is possible to invoke a message on an object that has no implementer for it. In those cases the default message implementation for a message is called. By default, the default implementation for unicast messages throws a "not implemented" DynException and the default implementation for multicast messages does nothing. The user may customize the behavior of default implementations.

Whenever the user wants to customize the default implementation of a given message, the first step is to add `HasDefaultImpl="true"` to the attributes of the message in the Dyn definition. If you try to compile it immediately, the compiler will tell you that there's a missing interface implementation in a specific class. By default this class is called DefaultMessageImplementations. This name can be configured from the Dyn definition. This class is defined as 'partial'. In order to be able to give custom default implementations, you must create a new part of the class. Create a new file and write in it `public partial class DefaultMessageImplementations {`. You can then insert the missing interface implementations into this part of the class.

The default implementation of a multicast message will never be called if there's at least one Component implementing it. Dispatch to the default implementation is as fast as the normal message dispatch. Default implementations receive all parameters passed to the message, but do not receive the instance of the object that didn't have the necessary implementation.

###Bids and priorities
Any component may implement any message. Thus, an ambiguity may arise whenever multiple components implement the same message. The user may disambiguate these situations using bids and priorities.

####Bids
Message implementations may "bid" to have their implementation picked. The message implementer with the highest bid is picked to be the message implementer for the given object type (and canonical component set). If there are more than one unicast messages with the highest bid, then an exception is thrown when you try to create an object with this conflicting component set.
To set the bid on a message implementation, put the Bid attribute on the method implementing the message, e.g.:

```
public class TestClass : GameMsgs.TestMessage
{
	[Bid(1)]
	public void TestMessage()
	{
	}
}
```

The default bid is 0. You can also use negative bids to mean that some particular implementation should be used only in the absence of a "default" (one without a bid) or higher.
Multicast messages usually don't need to use bids. However, that's still possible. If you decorate your implementation with a Bid, then only the set of implementers with the highest bid will be the set of implementations that will be called when the multicast message is invoked.

####Priority
You can decorate multicast message implementations with the `[Priority]` attribute, whenever you need to enforce a particular ordering of implementation execution. For example, it's useful to make certain that a given implementer will always be the first or the last in the implementation invocation list. Implementations with a higher priority will be called earlier in the invocation list. You can also have negative priorities. The default priority is 0. There is no guarantee for the order of invocation of implementations with the same priority.
You can use both the Bid and Priority attributes on a single message implementation.
It is an error to put the Priority attribute on a unicast message implementation.

###Serialization
Objects can be serialized and then recreated from their serialized data. Internally the library uses `XmlSerializer` for serialization, so all attributes controlling serialization with `XmlSerializer` work with object serialization as well. It is important to mention that not all components that are part of an object get serialized – usually there are only a handful of components that contain serializable data and most components contain a lot of logic. Moreover, game objects should be serializable in one environment (e.g. server-side where there may be a lot of server-only components) and deserializable in another (e.g. client-side deserialization where there may be client-only components). This makes it imperative that component serialization is strictly opt-in and it's generally a good idea to serialize only POCO components, i.e. components that contain data and little to no logic.

Serialization and deserialization is done with the methods `DynFactory.Serialize()`, `DynFactory.SerializeXml()` and two overloads of `DynFactory.Deserialize()`. The serialization methods can work with both plain strings containing XML and `XNode` instances.

There are two ways of serializing components, both are opt-in.

####`[SerializedComponent]`
Applying the `SerializedComponent` attribute to a component class makes the component opt-in for serialization. The component will be serialized as part of the object and its fields and properties will be serialized in the usual way XmlSerializer serializes normal classes. Attributes related to XmlSerializer like `XmlIgnore` and `XmlType` will still work.

####`[DelegatesSerialization]` and `ICustomSerializable`
The library supports a more advanced mode of serialization that employs the Memento design pattern. In this mode, you will have a component that includes data (that may or may not be in a form appropriate for serialization) as well as logic. You will then write a new class – the memento, that contains the necessary information to recreate the original component from it, as well as methods that can fill in the data from the component into the memento and vice versa. This is the preferred method for serialization as it keeps mementoes tight and makes it unnecessary to duplicate information in the component – once in the form needed for serialization (e.g. some string name), and once again in the useful form of a runtime object that was represented by the string.

To use the memento pattern you must execute the following steps:

1. Create a memento class containing all the necessary data to recreate the original component. You can use all attributes associated with XmlSerializer here – XmlIgnore, XmlType, etc. It is preferable that this class is a nested class of the component. Its type name must be globally unique, since class names aren't qualified when writing their type information into XML.
- Add the `[DelegatesSerialization]` attribute to the component class. Its constructor argument should the Type of the memento.
- Add the `[Memento]` attribute to the memento class. Its constructor argument should be the Type of the component class.
- Implement `ICustomSerializable` in your component class.
Let's assume that the component to serialize is RpgStats and its memento is the nested class RpgStats.RpgStatsMemento. A bare bones implementation will look like this:

```
[DelegatesSerialization(typeof(RpgStatsMemento))]
public class RpgStats : ICustomSerializable
{
	public object ToSerializable()
	{
		return new RpgStatsMemento {};
	}
	public void FromSerializable(object memento, object context)
	{
	}

	[Memento(typeof(RpgStats))]
	public class RpgStatsMemento
	{
	}
}
```

`ICustomSerializable` defines two methods:

- `ToSerializable()` – this method must convert the current component instance into a new instance of the memento type.
- `FromSerializable()` – this method must fill in the current component instance from the memento given in the first argument. The 'context' here is the same as the 'context' parameter passed to the `DynFactory.Deserialize()` method. It is usually used to locate some lookup structures from which the component can receive enough context information to finish its deserialization.

###Multicast beacon
Multicast messages can be used as events that get automatically wired to the respective implementations in all relevant components. This, however, also means that these implementations can only be in the form of message implementations in components that are part of the respective object. If you need to listen to events (multicast messages) from outside of the object you have two options.

Let's say for example, that you have a multicast message `PositionChanged()` and you would like to listen for it outside of the DynObject.

The first approach is rather straightforward – create a listener component, let's say `PositionChangedListenerForSomeObserver`, implement the `PositionChanged` message in it and in the implementation call back the respective Observer. Although obvious, this approach is bothersome as it requires you to create a component class for every type of Observer and bloats the component table with listener components.

The second approach is to use a multicast beacon. This is a generated class that implements a list of multicast messages, contains one C# event per multicast message and fires the respective event in its implementation of each message. For our example of `PositionChanged()` it will look something like this:

```
public class Beacon : Dyn.Component
	, GameMsgs.PositionChanged
{
	public event GameMsgsDelegates.PositionChanged PositionChangedBeacon;

	public void PositionChanged()
	{
		var evt = PositionChanged;
		if (evt != null)
			evt(DynThis);
	}
}
```

After creating the beacon, you can connect to it with e.g. `obj.GetBeacon().PositionChangedBeacon += OnPositionChanged`. Note that the first parameter of the event handler is of type DynObject and specifies which object has just dispatched a multicast message through the beacon. The rest of the parameters are identical to the parameters in the message signature.

Note: always remember to disconnect from beacons (and events in general) to prevent memory leaks.
The pros and cons of both approaches are given in the following table:

|What |Custom listener components|Multicast beacon|
|-----|--------------------------|----------------|
|Amount of code|Bad: dedicated component classes, plumbing code.|Good: the code is auto-generated.|
|Listener lifetime|Good: the lifetime of the listener is maintained automatically.|Bad: you must not forget to remove any delegates from the beacon event, when you don't need them anymore.|
|Memory footprint|Bad: bloat of the component table|Good: only a single multicast beacon component per component provider|
|Reusability|Bad: usually custom listener components are written for a single observer.|Good: any observer can connect itself to the beacon.|

In order to use a multicast beacon you must first generate the class. To do so, add the special tag MulticastBeacon to the Components section of your Dyn definition. The value of the element shall be the name of the class implementing the beacon.

The attributes of the `MulticastBeacon` element are the same as those of the `Component` element plus a few more specific to beacons:
- `OptOut` – Boolean field. If this is false, then then the multicast beacon will be "opt-in", i.e. multicast messages must explicitly include themselves for transmission over the beacon, by setting their `GenerateBeacon` attribute to true. If this field is true, then the multicast beacon will be opt-out, i.e. all multicast messages will be transmitted through the beacon, unless they explicitly opt out by setting their `GenerateBeacon` attribute to false.

It's recommended to keep the beacon opt-in and generate beacons for messages on an as-needed basis.

###Message overloads
Messages can be overloaded. This means that you can have multiple extension methods for message invocation with the same name but with different parameter lists. As you know, components declare that they implement a given message by implementing its respective message interface. Since message interfaces cannot have the same name, they must somehow be distinguished. This is done through the Overload attribute of the Message element in the Dyn definition. Suppose you have two messages `void SetValue(string val)` and `void SetValue(int val)`. To distinguish them you should add an Overload attribute to their definition, e.g.:
```
<Message Overload="String">
	void SetValue(string val);
</Message>
<Message Overload="Int">
	void SetValue(int val);
</Message>
```
This will create an overloaded message named SetValue with both signatures above. This will also create the message interfaces named SetValueString and SetValueInt respectively. Basically the value of the Overload attribute will be appended to the name of the message to produce the name of the message interface that you must use to implement the given overload. Note that you can omit a single Overload attribute from the overload set of a given message, as the empty overload name string is just a special case, e.g.:
```
<Message Overload="String">
	void SetValue(string val);
</Message>
<Message>
	void SetValue(int val);
</Message>
```
This will create two message interfaces: `SetValue` (for the int case) and `SetValueString` (for the string case). This is useful if there is a "preferred overload" or you're adding new overloads to an existing, previously non-overloaded message.

###Chaining unicast messages
Unicast messages are special in that there is only one message implementation that will get called (the highest bidder). It's useful, however to be able to call the runner-ups in the bidding process. This can be used to implement the Chain of command design pattern between components.

To call the next bidder you can use the special message form: obj.{SomeMessage}ForNextBidder(). This method has basically the same signature as the original message. The only differences are:
- The `-ForNextBidder` suffix – this is used to differentiate between the message forms.
- The first parameter of this method is the Type of the component that is the current bidder in the chain. Usually you call the `–ForNextBidder` form within the message implementation in some component and you can just call it with the type of the current component.

If there is no next bidder, an exception is thrown. It is undefined whether the default message implementation is considered a "last bidder" and whether it can be called in this way.

###When you can't inherit from Component
When designing components, it is best to inherit straight from Component. This way you get comfortable access to DynThis. At times, however, that may not be a viable option. For example, you may have to inherit your component from some other framework's base classes. The library provides a ready workaround for this case. Instead of inheriting from Component, you can compose it and still get all its integration features. This is done like so:
```
public class VisualComponent : FrameworkElement, IHasObjectHook
{
	private Component component = new Component();

	IObjectHook IHasObjectHook.ObjectHook
	{
		get { return component; }
	}
}
```
In this example our component is named `VisualComponent` and inherits from `FrameworkElement` – a framework base class. It also implements the `IHasObjectHook` interface – the library uses this interface to obtain an object where it can store the DynThis property as well as call object event methods. Then you add and initialize a field of type Component to your class and explicitly implement IHasObjectHook to return the value of the `component` field. After that, whenever you want to use `DynThis`, you write instead `component.DynThis`. Also, whenever you want to receive object events, you can subscribe to the `DynObjectCreated` and `DynObjectMutated` events in `Component`.

You can even go further and instead of composing an instance of `Component` you can implement the interface IObjectHook and manually store an instance to the container object as well as implement the processing of object events. Essentially, you'll reimplement (like a manual mixin) the Component class inside your own component. For a comprehensive example, read the code of the Component class itself.

Performance
-----------
The library is designed for game programming, which makes it necessary that it be as fast as possible (and it is). However, there are several performance-enhancing features that can be used by the user to further improve its performance.

###Message performance
Messages are already very fast by default. Multicast messages are practically as fast as unicast messages. You can think of the performance of multicast messages as a unicast message that fires a C# event (itself a very low overhead operation). The dispatch to a default implementation is as fast as the dispatch to a normal message implementation.

Note that messages with the attribute `ThruInterface="true"` and generic messages suffer a small performance penalty on invocation. The penalty is unfortunately exacerbated for multicast messages. In performance critical situations you can improve your performance by using the most common form of messages, i.e. the message shouldn't be generic and it shouldn't use the ThruInterface option, especially if it's a multicast message.

If you know a priori the target component of an invocation of a unicast message, it is slightly faster to call the method on the component directly, e.g. `obj.Get{SomeComponent}().Message()`, instead of relegating the call to a unicast message, e.g. `obj.Message()`.

###Object creation performance
The fastest way to create an object is straight from the associated `TypeInfo` for that object, by calling `TypeInfo.CreateObject()`. This is an inherently fast operation with little overhead.

The creation of a TypeInfo instance is usually a very slow operation. To alleviate this, the library caches all TypeInfo's that come to existence using a WeakReference. So, as long as a single TypeInfo for a given object exists and the weak reference is valid, subsequent creation of objects of that type is a fast operation. You can also create these TypeInfo's explicitly by calling `DynFactory.CreateObjectType()` and optionally cache them for further use. If you don't, the first creation of an object of that type will create the associated TypeInfo, which also means that the first object of a type will take a while to create (on the order of milliseconds for large component providers).

Another time consuming operation is applying all type analysis rules to the component set passed to `DynFactory.CreateObject()` function. This operation is always necessary, because the factory doesn't (and probably shouldn't) cache what TypeInfo will be mapped to a given set of components. To reduce the need of repeated type analysis you can use object type keys. The concept is as follows – you have a place in your code where you produce a lot of "the same" objects, i.e. having the same canonical component set. You could cache the TypeInfo at that place, but you don't know when you'll have a factory initialized to cache it. So, you can use a special object type key that is just a token for a given type. The factory is able to map the key to the corresponding TypeInfo with no type analysis at all. This is a good idea, whenever you don't want to or can't stuff a TypeInfo instance into a static variable. This is done in the following pattern:

```
private static object SpecificObjectType = new object();
...
var fastObj = factory.CreateObjectFast(SpecificObjectType, ...components);
```

In this example `SpecificObjectType` is a token for the type of object you create. After the first call to `CreateObjectFast()`, the factory will cache the TypeInfo and associate it with this token. Subsequent calls to `CreateObjectFast()` will go straight to the appropriate TypeInfo. It is important that you always pass a compatible set of components to this call every time.

###Factory creation
Constructing a factory takes a lot of time. Usually this is no problem at all, since they're created once for the lifetime of the application. When using factories in a web application or a web service, you can initialize the factory lazily and store a reference in a static variable. This reference will be invalidated only when the app domain is unloaded (e.g. due to inactivity) and should be recreated (lazily) as this happens. This will ensure that the factory will not be recreated across many requests that are sufficiently close in time and thus no noticeable performance penalties will be suffered server-side.